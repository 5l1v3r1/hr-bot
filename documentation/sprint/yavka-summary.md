### Disclaimer:

![bot](https://raw.githubusercontent.com/dev-labs-bg/hr-bot/master/documentation/sprint/img/bot.JPG)

Всичко, което съм написал е плод на 3-4 дни проучване. Ако се интересувате от нещо, може да ме питате, но не очаквайте да знам много по темата. Освен това, описанията ми на теорията, на която се базирам, са много кратки и непълни. Добавил съм линкове към материалите, които съм използвал, в квадратни скоби.

Също така, в последния ден от спринта намерих една #безплатна книга[11] за изкуствен интелект, където всичко е обяснено много подробно. Ако някой желае да задълбае в нещо, и не мога да му дам отговор, може да потърси и там.

### Ден първи:

Срещнахме се с Данчо и вербувахме Радо за каузата да оставим HR-ите без работа™. Качихме се в тихата стая и направихме груба разбивка на нещата, които искаме да се случат.

Най-общо, идеята бе да съберем информация за програмисти от профилите им в LinkedIn, GitHub и StackOverflow в наша база от данни. Имаме landing page, на който работодатели могат да търсят хора с определени умения. Когато получим запитване, търсим какви хора имаме в базата, след което им пращаме имейл от HR бота, който започва да ги разпитва. Ако им хареса предложението (и програмистът отговаря на описанието на работодателя), пращаме информация на работодателя кои хора сме намерили.

След като написахме стъпките на дъската видяхме, че нещата естествено се разбиват на отделни модули. Данчо предложи да пробваме да ги направим на отделни microservices, и пое задачата да види как ще стане това. Радо каза, че не правил REST API до момента, така че пое задачата да направи GitHub, LinkedIn и StackOverflow parser-и, като решихме първо да се започне с GitHub, защото имат API (за разлика от LinkedIn, за който трябва някакъв scraper). За мен остана имплементацията на бота, с идеята Данчо и Радо да се включат след като свършат своите задачи, и да прескочат фазата на проучване.

Разбивката на microservice-ите и реда, в който се случват нещата може да видите на схемата на дъската:

![Day 1](https://raw.githubusercontent.com/dev-labs-bg/hr-bot/master/documentation/sprint/img/day1.jpg)

### Ден втори:

Направих проучване за различни бот фреймуърци и услуги. Намерих най-различни услуги като pandorabots.com (chatbots.io), Microsoft Bot network, ChatScript, ABot (и други, които ми минаха през погледа, но не се сещам за имената им вече (sorry)). Някои от платформите бяха платени, други работеха само по определени канали (Facebook chat, Skype), а идеята бе да направим нещо, което може да комуникира по имейли.

Първо се спрях на ChatScript, понеже е open source и ботове, имплементирани на базата му, са финалисти на Loebner конкурс (Turing test който оценява колко “човешки” се държи един бот) за 2010, 2011, 2012 година, така че би трябвало да е мощен фреймуърк.

Прекарах оставащата част от деня в опити да подкарам това чудо и да се преборя с много малкото документация[1][2], която идва с него. Нямах много късмет. Единственото, което успях да подкарам е бота да пита 1, 2 въпроса, и да сравнява отговорите с нещо като regex. Проблем беше, че нямах идея какво правя. Това, което подкарах, беше copy/paste от някакъв sample файл, за който нямаше документация.

Реших, че ChatScript е задънена улица.

### Ден трети:

След малко размишления предната вечер реших, че няма смисъл да търся нов фреймуърк или онлайн услига. Ако ползвам нещо готово няма да науча нищо за технологията и алгоритмите, а идеята на спринтовете е техническо предизвикателство. Така стигнах до решението сам да си имплементирам бота. Беше малко рисковано, защото ми оставаха само 3 дни, и имаше вероятност спринта да се провали заради това решение.

След малко търсене в интернет намерих статия, която сравнява различните стратегии за правене на чат ботове[3][4]. Натъжих се много, защото си мислех, че използват нещо различно от pattern matchig и статистика. Оказва се, че психологическите трикове и лингвистиката играят много по-голяма роля от алгоритмите за изкуствен интелект.

Все пак, проучването не бе изгубено време. Взаимствах идеята за някакъв общ парсър, който анализира изречения и прави заключения за тях. “Изкусвеният интелект“ генерира отговори на база на тези заключения[3]. Ето концептуална схема на това, което ми се въртеше в главата:

![Parser](https://raw.githubusercontent.com/dev-labs-bg/hr-bot/master/documentation/sprint/img/parser.JPG)

(Споко, има обяснение какво представлява контекстът по-долу, така че няма нужда да ръкописен json :)

Идеята е да разделя анализа на входното изречение от връщането на отговора. Искам да направя това, защото входното изречение може да има един и същи смисъл, но да бъде написано по различен начин. Например:

- "I have 9001 years of js experience."
- "I have 9001 years of JS exp.!"
- "I’ve 9001 years of JS experience."
- "I’ve programmed in JS for 9001 years."
- "I first started programming JS 9001 years ago."

Ако се опитам да направя regex (или някакъв подобен pattern matching) за всяка една разновидност има 2 неща, които могат да се случат:
1. Да ме заболи главата от поддръжката на всички възможни пермутации на това изречение.
2. Да направя някакъв много общ pattern matching.

Нека решим, че избера по малкото зло (общ pattern matchin). Виждам, че във всички изречения има общи думи: “js”, “9001 years“. Мога да направя нещо, което търси ключовите думи ”js“ (и други езици) и ”<цифра> <years>“, и просто да върна някакъв отговор.

За жалост, има други случаи, които не се вписват в този pattern, а са еквивалентни. Например: “My JS experience is over nine-thousand years!”

А изреченията “I haven’t written any JS in 20 years.” и “12 days of JS experience is enough for me to qualify as a pro front-end developer, right?” биха match-нали нашия pattern, но значението е много различно.

Това е един от големите проблеми на pattern matching-а: ако pattern-а е твърде конкретен - пропускаш много входни изречения, но ако е твърде обширен се получават фалшиво позитивни тестове. За да работи добре един парсър, трябва правилата да са умерено стриктни. За да стане това по-лесно, обаче, трябва да има удобен начин да се пишат и преизползват правила.

Още едно търсене в интернет, и попаднах на тази библиотека[5], заедно с опростения и вариант[6], който използвам в имплементацията си. Ето как тя ми помага:

Входното изречение “I have 9001 years of js experience!” се разбива на отделни езикови частици, например:

I<PRP>  have<VBP>  9001<CD>  years<NNS> of<IN>  js<NN>  experience<NN>

Частичите PRP, VBP, и други са кодировката, която NLTK използва, за да анализира думи. Значението им е следното:

- PRP - PeRsonal Pronoun
- VBP - VerB Present form
- CD - CarDinal number
- IN - prepositIoN
- NNS - NouN (poSsesive) 
- NN - NouN

Въпреки, че този анализ може да не изглежда много полезен, той позволява изреченията: “I have 9001 years of js experience” и “I’ve had 9001 years of js experience”, и “I’ve over nine-thousand years of js experience” да се разпознаят като еквивалентни много по-лесно от regex.

След няколко часа ръчкане на библиотеката, имах анализатор, който може да вземе изречението: “I have 9001 years of js experience” и да ми върне това:

```
{
    'is_agreement': False,
    'sentiment': Sentiment(polarity=0.0, subjectivity=0.0),
    'is_question': False,
    'contains_time_period': [{'at': (7, 16), u'year': 9001}],
    'is_language_related': {'JS': (21, 23)}
}
```

Имайки тази информация, бота трябва да вземе решение какъв отговор да върне. Имплементацията ми на това бяха някакви хардкоднати if-ове, които проверяват контекста и връщат отговор. За следващия ден си поставих задачата да оправя това.

### Ден четвърти:

Вече имам някаква идея как да парсвам текст и да връщам някакъв хардкоднат отговор, но това изобщо не е близо до AI.

В една статия видях идеята за онтологична релационна база за чат ботове. Не съм се задълбочил много, защото няма как да имплементирам това в рамките на 2 дни, но ще опиша идеята накратко:

Бота има изградена база данни със значенията на различните думи, което му позволява да прави логически връзки от вида:

“PHP е програмен език. PHP е обектно ориентиран език. На мен ми е зададено търсене за хора с OOP умения. Този програмист знае PHP, така че е вероятно да е потенциален кандидат”.

Ако сте се занимавали с (или сте чели за) експертни системи[12][7] (не се притеснявайте ако не сте, не е сложно), ще ви направи впечатление, че този алгоритъм е от 1970 година, и се ползва навсякъде, където трябва да се стигне до решение на база някакви правила. Пример за такъв софтуер е почти всеки troubleshooter, както и почти всяка услуга, която ви дава предложения на база това какво харесвате или не. В случая, нашият симулиран екперт HR човек.

Та, след като представих идеалния вариант, където системата сама взима решения от информацията, която има, ще представя и алтернативата, която съм имплементирал. Нарекохме го “Call center”.

Понеже пишем правилата за парсване на ръка, е много трудно да се предвидят всички ситуации. Затова, с Данчо решихме да имплементираме бота така, че да има сценарий, в който той се опитва да вкара потребителя. Идеята ми беше да започна с много прост flow от вида:

1. Бота те пита какъв опит имаш
2. Бота парсва опита, и пита за потвърждение
    - Ако потвърдиш, продължаваш към стъпка 3
    - Ако отречеш, се връщаш на стъпка 1.
    - Ако бота те е питал за потвърждения на опит повече от 2 пъти до момента, получаваш подсказка за формат, който ботът със сигурност би разбрал.
3. Бота ти казва, че си супер много як, и приключва разговора. :)

Този тип сценарий много прилича на менюто на мобилните оператори (“За Англйиски, натиснете 9. За проверка на минути, натиснете 2”). Удобен е, защото е много лесен е за програмиране, тъй като имаме точна идея как трябва да се държи ботът, и има краен брой състояния, в които може да бъде един разговор. Всичко е дискретно.

Всяка една от тези стъпки могат да се имплементират с if, else, else if спагети, естесвено, но идеята е лесно да могат да се добавят повече стъпки и подусловия.

Някой от вас вече знаят какво съм намислил. След като разговорът има краен брой дискретни състояния, мога да го моделирам като краен автомат. Ето как изглежда схемата на по-горния сценарий: 

![Finite state machines](https://raw.githubusercontent.com/dev-labs-bg/hr-bot/master/documentation/sprint/img/state_machine.jpg)

В тази картинка има проблем, обаче.

Когато описваме каквато и да било логика с краен автомат, резултатът винаги е по-многословен от това, което можем да напишем на един програмен език. В зависимост от това колко стриктно се придържаме към теорията на графите, може да се наложи да добавим състояния, които не правят нищо, или да правим състояния, към които има само един път, и то е безусловен! Всичко това е името на преизползване на състоянията.

Естествено, тези проблеми могат да се решат, като имплементацията ни позволи да напишем опростен граф (примерът в дясно, където прескачам от “e” към “A”, вместо да мина през “h”, както и сливането на “А” и “B” в “AB”, защото има само един безусловен преход).

Друго решение е да можем да дефинираме отделни парчета като самостоятелни крайни автомати, и да ги “вложим“ в състояният на по-глобален краен автомат (разделяй и владей). Това съм показал на сбитата драсканица в долния край на дъската.

Което и да си изберете, две неща стават ясни:

1. Не е нещо, което се имплементира за един ден (или поне аз не мога).
Въпреки, че промени се правят по-лесно, логическата последователност не се опростява.
2. До края на деня търсих някаква библиотека за вложени крайни автомати, но не намерих нещо, което върши работа. Имплементирах нещо тестово, колкото да пробвам идеята на живо.

### Ден последен:

След малко размисли предната вечер, реших, че броят крайни състояния не е толкова голям проблем, колкото поддръжката на връзките помежду им. Ако ботът сам успее да навърже състоянията и да реши по кой път да мине, щеше да е много по-лесно за писане.

Оказва се, че има такова нещо™[8] в AI теорията наречено Goal Oriented Action Planning (или GOAP), което прави точно това, което искам. В статията е обяснено много по-добре, от колко аз бих могъл с моите 2 часа проучване по темата, но идеята на кратко е:

1. Дефинират се действия, които ботът може да предприеме. Например: “питай човека какъв опит има”, “потвърди опита”, “дай подсказка”. Това са състоянията на нашия краен автомат от по-рано.
2. Определят се зависимости между отделните действия. Например: “За да потвърдиш опита, първо трябва да си питал човека какъв опит има.”, “Ако човекът е потвърдил опита си, не го питай повече за това какъв опит има.”
3. Определя се крайно състояние, до което ботът трябва да достигне.
4. Определят се различни тежести за всяко действие, което може да извърши ботът. Например, ботът може да пита колко опит имаш с дадена технология, но не задължително. Препоръчително е, обаче, да пита.
5. Едно A* търсене по-късно, и ботът намира оптималния ред от действия, които трябва да извърши, за да изпълни целта си.

Отново се поразтърсих за някоя библиотека, която имлементира GOAP, но не намерих нищо, което да работи достатъчно динамично. Всяка библиотека изискваше да дефинирам променливи, от които зависи всяко действие на бота, вместо да мога да подам функция, която да взима решения на базата на контекста.

Тъй като ми оставаха само около 4-5 часа до края на спринта, хванах първата, която ми се стори по-лесна за ползване, и нахвърлях нещо доста грозно, но което използва функции за взимане на решенията си. Резултатът можете да видите в репото. Ето два тестови "разговора":
```
HR Kiri: What programming experience do you have?
> I have 4 years of php and just as much JS under my belt. I also rock at python.
HR Kiri: So, you have experience with Python, PHP, JS?
> no
HR KIRI: Alright, let's try that again.
HR Kiri: What programming experience do you have?
> Well, I can do bash?
HR Kiri: So, you have experience with Bash?
> yes
HR KIRI: Awesome!
```

```
HR Kiri: What programming experience do you have?
> I have no experience whatsoever.
HR KIRI: I'm sorry, I don't understand you.
HR Kiri: What programming experience do you have?
```

А ето разговор с дебъг лог:
```
-- <Current goal: ask_about_experience>
HR Kiri: What programming experience do you have?
> I have 3 years of php experience and a month of js under my belt.
-- <Context: {'is_agreement': False, 'sentiment': Sentiment(polarity=0.0, subjectivity=0.0), 'is_question': False, 'contains_time_period': [{'at': (37, 43), u'month': 1}, {'at': (7, 13), u'year': 3}], 'ask_about_experience': True, 'is_language_related': {'PHP': (18, 21), 'JS': (48, 50)}}>
-- <Current goal: ask_confirm_language_experience>
HR Kiri: So, you have experience with PHP, JS?
> no
-- <Context: {'is_agreement': False, 'sentiment': Sentiment(polarity=0.0, subjectivity=0.0), 'ask_confirm_language_experience': True, 'contains_time_period': [], 'is_question': False, 'is_language_related': {}}>
-- <Current goal: confirm_language_experience>
HR KIRI: Alright, let's try that again.
-- <Current goal: ask_about_experience>
HR Kiri: What programming experience do you have?
> Some php.
-- <Context: {'is_agreement': False, 'sentiment': Sentiment(polarity=0.0, subjectivity=0.0), 'is_question': False, 'contains_time_period': [], 'ask_about_experience': True, 'is_language_related': {'PHP': (5, 8)}}>
-- <Current goal: ask_confirm_language_experience>
HR Kiri: So, you have experience with PHP?
> yes
-- <Context: {'is_agreement': True, 'sentiment': Sentiment(polarity=0.0, subjectivity=0.0), 'ask_confirm_language_experience': True, 'contains_time_period': [], 'is_question': False, 'is_language_related': {}}>
-- <Current goal: confirm_language_experience>
HR KIRI: Awesome!
```

### Заключение:

Да, HR-ите все още не са уволнени[9], и ботът определено не е завършен. Разочарован съм, че чат ботовете не са се развили толкова много, колкото си мислех[10]. Също, съм разочарован от себеси, че не можах да докарам бота до нещо, което върши работа (Дори не е microservice (Sorry, Данчо)).

За сметка на това научих доста неща и имах възможността да си поблъскам главата с интересни проблеми, което за мен е много по-важно от това да използвам нещо наготово, дори и резултатът да ми върши работа, а моята имплементация - не.

---
[1] https://htmlpreview.github.io/?https://raw.githubusercontent.com/bwilcox-1234/ChatScript/master/HTMLDOCUMENTATION/ChatScript-Basic-User-Manual.html

[2] https://htmlpreview.github.io/?https://raw.githubusercontent.com/bwilcox-1234/ChatScript/master/HTMLDOCUMENTATION/ChatScript-Memorization.html

[3] http://www.gamasutra.com/view/feature/134675/beyond_fa%C3%A7ade_pattern_matching_.php

[4] http://thesai.org/Downloads/Volume6No7/Paper_12-Survey_on_Chatbot_Design_Techniques_in_Speech_Conversation_Systems.pdf

[5] http://www.nltk.org/

[6] https://textblob.readthedocs.io/en/dev/

[7] https://en.wikipedia.org/wiki/Expert_system

[8] https://gamedevelopment.tutsplus.com/tutorials/goal-oriented-action-planning-for-a-smarter-ai--cms-20793

[9] Но и бота, който сковах, не е превзел света все още, така че не се оплаквам.

[10] На няколко пъти имаше изказвания “Е, Cleverbot е доста добър, значи има начин и ние да го направим.” Оказва се, че cleverbot използва много хитър трик - когато някой го пита нещо, за което той няма отговор, запомня въпроса, и сменя темата. След това, в друг разговор с друг потребител, cleverbot задава въпроса от по-рано, запомня отговорът, който човекът му дава, и го използва в следващи разговори. Затова отговорите на cleverbot звучат интелигентни - написани за от реални хора! Проблемът е, че ботът все пак не знае какво говори. В един момент може да каже, че мрази домашните любимци, а в следващия, че кучетата са любимото му животно.

[11] http://artint.info/html/ArtInt.html

[12] http://www.ecommerce-digest.com/expert-systems.html
